% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mutual.information.utils.R
\name{calculate.mutual.information.pairwise.data.types}
\alias{calculate.mutual.information.pairwise.data.types}
\title{Compute mutual information from list of data.frames/matrices}
\usage{
calculate.mutual.information.pairwise.data.types(
  omics.data.list,
  data.types.categorical = setNames(rep(FALSE, length(omics.data.list)),
    names(omics.data.list)),
  comparisons = NULL,
  match.rows = TRUE,
  match.columns = TRUE,
  filter.rows = FALSE,
  filter.threshold = NULL,
  normalize.input = FALSE,
  n.permutations,
  calculate.pvalue = FALSE,
  FDR.threshold = 0.05,
  n.cores = 1,
  n.bins = NULL,
  FD.n.bins = FALSE,
  sample.size.bins = TRUE,
  equal.frequency.bins = FALSE,
  normalize.mutual.info = TRUE,
  use.shrinkage = FALSE,
  simple.sample.size.correction = FALSE
)
}
\arguments{
\item{omics.data.list}{a named list of data.frames/matrices with samples in columns and gene-wise data in rows. Names will be used for detailing pariwse comparisons in output.}

\item{data.types.categorical}{a named vector or list specifying whether each data type in omics.data represents categorical data. Used only if FD.n.bins is TRUE.
If so, the number of bins used is equal to the number of unique values for each row of input.matrix.1 separately. Defaults to FALSE for all elements of omics.data.}

\item{comparisons}{a named list that details the pairwise comparisons to be made. Each element of the list should be a vector of length two indicating a pair of data types from omics.data.list which will be compared.
Names of the list will be used for outputs. Defaults to NULL (compare all input data in a pairwise fashion)}

\item{match.rows}{if TRUE, common row.names of input.matrices are identified and used for computation of mutual information
If FALSE, input matrices should have the same number of rows, which will be compared in order i.e. the first row of input.matrix.1 compared with the first row of input.matrix.2. Defaults to TRUE.}

\item{match.columns}{if TRUE, columns of input matrices will be orderd by shared colnames (i.e. sample names). If FALSE, columns of input matrices should already be matched. Defaults to TRUE.}

\item{filter.rows}{whether to filter rows from each data type pair after intersecting by column names (samples). This may be desirable as data may become 'too sparse' after intersecting
between a given data type pair. Defaults to FALSE.}

\item{filter.threshold}{used if filter.rows is TRUE. What is the minimum proportion of samples that should have non-zero values for each data type pair after intersecting by sample. e.g. 0.5 would indicate >= 50% of samples must have non-zero observations.
This can be a single value for all data types, or a named vector/list with a threshold for each data type.}

\item{normalize.input}{should data be normalized using the inverse normal transformation.
See `?RNOmni::RankNorm`. Normalization is performed after intersecting data types by sample and optional filtering of rows. This may be more desirable than normalizing data before intersection and sampling.
Defaults to FALSE}

\item{n.permutations}{if calculate.pvalue = TRUE, determines number of permutations to use}

\item{calculate.pvalue}{whether to calculate probability of mutual information using a permutation-based approach. Defaults to FALSE}

\item{FDR.threshold}{threshold for determining number of significant genes in returned summary statistics data.frame. Defaults to 0.05}

\item{n.cores}{how many cores to use for parallelization of mutual information calculation. Parallelization occurs across genes/rows of input matrices. Defaults to 1.}

\item{n.bins}{number of bins to use in discretizing data, applied to both input vectors. Used if FD.n.bins = FALSE.}

\item{FD.n.bins}{whether to calculate number of bins for discretization based upon input data using the Freedmanâ€“Diaconis rule.
Performed for both input vectors separately. Overides n.bins and sample.size.bins. Performed for both input vectors separately. Defaults to FALSE}

\item{sample.size.bins}{whether to calculate number of bins for discretization as afunction of sample size (N).
Bin number = N^(1/3). Defaults to FALSE}

\item{equal.frequency.bins}{whether to use an adaptive bin width which aims to equalize the frequencies of observations in each bin. Defaults to FALSE}

\item{normalize.mutual.info}{should the mutual information be normalized (bounded between 0-1)}

\item{use.shrinkage}{whether to perform shrinkage when calculating mutual information using the James-Stein estimator. Defaults to FALSE}

\item{simple.sample.size.correction}{apply a naive correction to reduce the bias coming from a limited sample size}
}
\value{
A named list with an entry for every pairwise comparison of input matrices/data.frames (excluding self comparisons)
If calculate.pvalue = FALSE, a single matrix containing mutual information is returned
If calculate.pvalue = TRUE, a list of 3 matrices is returned with: mutual information, expected (median of permuted) mutual information, p value probability of observed mutual information
}
\description{
Rows of data from each data.frame/matrix will be used to compute mutual information. Each pairwise combination of inputs will be compared, excluding self-comparisons
Either rows will be matched for computation of mutual information via common row.names (if match.rows is TRUE), or each row pair of rows will be matched in turn
Matching of rows and colnames is optionally performed
Matching colnames (i.e. samples) and row.names (i.e. genes) are identified between pairs of input data.frames/matrices
}
\examples{
data('simple.data');

data.types.categorical <- c(
   data.a = FALSE,
   data.b = FALSE,
   data.c = TRUE # data.c contains categorical data
   );
   
### calculate mutual information between all pairs of datasets
set.seed(123);
mutual.info <- calculate.mutual.information.pairwise.data.types(
   omics.data.list = simple.data,
   data.types.categorical = data.types.categorical,
   match.rows = TRUE,
   match.columns = TRUE,
   sample.size.bins = TRUE,
   calculate.pvalue = TRUE,
   n.permutations = 100
   );

### plot results
data.type.colours <- setNames(BoutrosLab.plotting.general::default.colours(length(simple.data)), names(simple.data));

data.type.legend.labels <- names(data.type.colours);

miplot <- create.mutual.information.summary.plot(
   MI = mutual.info$MI,
   order.by.median = TRUE,
   data.type.colours = data.type.colours,
   data.type.legend.labels = data.type.legend.labels,
   summary.statistics = mutual.info$summary.statistics,
   return.plot = TRUE, # to save to file, set FALSE and use filename = '<plot-name>.tiff'
   return.plot.elements = FALSE,
   plot.width = 8,
   plot.height = 5
   );
miplot;
}
